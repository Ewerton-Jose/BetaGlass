<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Detecção • BetaGlass</title>
  <link rel="stylesheet" href="index.css" />
  <style>
    html, body { height: 100%; overflow: hidden; }
    .app-wrapper{position:fixed; inset:0; display:block;}
    .stage{position:fixed; inset:0; padding:0; margin:0;}
    /* Container em tela cheia com recorte (cover) sem distorcer */
    #webcam-container{position:fixed; inset:0; width:100vw; height:100dvh; overflow:hidden}
    /* O tamanho do canvas será ajustado via JS para manter proporção (cover) */
    #webcam-container canvas{ display:block; border-radius:0; }
    /* Botão central sobre o vídeo */
    .center-start{position:fixed; inset:0; display:flex; align-items:center; justify-content:center; z-index:10}
    #startBtn{z-index:11}
    /* Overlay da melhor predição */
    #top-prediction{
      position:fixed; left:0; bottom:calc(env(safe-area-inset-bottom) + 0px);
      width:100%; background:rgba(0,0,0,.55);
      padding:10px 14px; font-size:clamp(14px,4vw,18px); font-weight:600;
      backdrop-filter:blur(2px); z-index:9; text-align:center;
    }
    .hidden{display:none !important}
  </style>
</head>
<body>
  <div class="app-wrapper">
    <main class="stage">
      <div id="webcam-container" aria-live="polite" aria-label="Visualização da câmera"></div>
      <div class="center-start"><button id="startBtn">Começar</button></div>
      <div id="error" class="error" role="status" aria-live="assertive"></div>
    </main>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@latest/dist/teachablemachine-image.min.js"></script>
  <script>
    const URL = "https://teachablemachine.withgoogle.com/models/5aXNg7B01/";
    let model, webcam, maxPredictions;
    const startBtn = document.getElementById('startBtn');
    const errorDiv = document.getElementById('error');
    const webcamContainer = document.getElementById('webcam-container');
    let topDiv;

    function sizeCanvasCover(){
      if (!webcam || !webcam.canvas) return;
      const canvas = webcam.canvas;
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      let vidW = 640, vidH = 480;
      try {
        const v = webcam.webcam || webcam.video || null;
        if (v && v.videoWidth && v.videoHeight) { vidW = v.videoWidth; vidH = v.videoHeight; }
      } catch {}
      const arVideo = vidW / vidH;
      const arViewport = vw / vh;
      if (arViewport > arVideo) {
        // viewport mais largo que o vídeo -> expandir largura, ajustar altura automaticamente (corta em cima/baixo)
        canvas.style.width = vw + 'px';
        canvas.style.height = 'auto';
      } else {
        // viewport mais alto/estreito -> expandir altura, ajustar largura automaticamente (corta nas laterais)
        canvas.style.height = vh + 'px';
        canvas.style.width = 'auto';
      }
      canvas.style.position = 'absolute';
      canvas.style.top = '50%';
      canvas.style.left = '50%';
      canvas.style.transform = 'translate(-50%, -50%)';
    }

    async function init(){
      startBtn.classList.add('hidden');
      errorDiv.textContent = '';
      try {
        model = await tmImage.load(URL + 'model.json', URL + 'metadata.json');
    maxPredictions = model.getTotalClasses();
    const flip = false; // traseira não deve ser espelhada
    webcam = new tmImage.Webcam(640, 480, flip);
  // força câmera traseira (apenas traseira). Se não houver, falha.
  await webcam.setup({ facingMode: { exact: "environment" } });
        await webcam.play();
        window.requestAnimationFrame(loop);
        webcamContainer.appendChild(webcam.canvas);
        topDiv = document.createElement('div');
        topDiv.id = 'top-prediction';
        webcamContainer.appendChild(topDiv);
        sizeCanvasCover();
        window.addEventListener('resize', sizeCanvasCover);
        window.addEventListener('orientationchange', sizeCanvasCover);
  // Verifica se realmente veio traseira; se não, avisa.
  validateBackCamera();
      } catch(err){
        startBtn.classList.remove('hidden');
        if (err && err.name === 'NotAllowedError') {
          errorDiv.textContent = 'Permissão negada: autorize o uso da câmera.';
        } else if (err && (err.name === 'NotFoundError' || err.name === 'OverconstrainedError')) {
          errorDiv.textContent = 'Câmera traseira não disponível neste dispositivo.';
        } else {
          errorDiv.textContent = 'Erro ao inicializar: ' + (err.message || err);
        }
      }
    }

    async function loop(){
      webcam.update();
      await predictTop();
      window.requestAnimationFrame(loop);
    }

    async function predictTop(){
      const prediction = await model.predict(webcam.canvas);
      // Encontra maior prob.
      let best = prediction[0];
      for (let i=1;i<prediction.length;i++){
        if (prediction[i].probability > best.probability){
          best = prediction[i];
        }
      }
      topDiv.textContent = `${best.className} (${(best.probability*100).toFixed(1)}%)`;
    }

    startBtn.addEventListener('click', () => {
      // Redireciona para a página da câmera dentro da pasta yolo
      window.location.href = 'yolo/camera.html';
    });
    async function validateBackCamera(){
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const videoInputs = devices.filter(d => d.kind === 'videoinput');
        // Procura por labels indicando câmera traseira
        const backLike = videoInputs.find(d => /back|rear|environment|traseira/i.test(d.label));
        if (!backLike && videoInputs.length > 1){
          errorDiv.textContent = 'Aviso: usando outra câmera (traseira não identificada).';
        }
      } catch(e){ /* silencioso */ }
    }
  </script>
</body>
</html>
